# 正则表达式



## 元字符



| 代码 |             说明             |
| :--: | :--------------------------: |
|  .   |  匹配除换行符以外的任意字符  |
|  \w  | 匹配字母或数字或下划线或汉字 |
|  \s  |       匹配任意的空白符       |
|  \d  |           匹配数字           |
|  \b  |     匹配单词的开始或结束     |
|  ^   |       匹配字符串的开始       |
|  $   |       匹配字符串的结束       |



> 比如一个网站要求输入5到12位的qq号：可以使用：**^\d{5,12}$**



## 字符转义

如果想查找字符本身的话，比如  .  * ,会被理解成别的意思。这时就需要用 \ 来取消这些字符的特殊意义。

比如： \\.  \\*



## 重复

| 代码/语法 |       说明       |
| :-------: | :--------------: |
|     *     | 重复0次或更多次  |
|     +     | 重复1次或更多次  |
|    ？     |   重复0次或1次   |
|    {n}    |     重复n次      |
|   {n,}    | 重复n次或n次以上 |
|   {n,m}   |    重复n到m次    |



## 字符类

查找数字 字母 空白啥的很简单，元字符里面已经包含了许多对应的集合。那么 想匹配 普通字符该怎么办呢？

用 **[]**  ,比如想匹配元音字符，可以用 [aeiou]。

也可以轻松指定一个 **字符范围**。比如**[0-9a-zA-Z]**,这个意思几乎等同于\w（ 不算中文）



## 分枝条件

正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用**|**把不同的规则分隔开。听不明白？没关系，看例子：

0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。

\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。

\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。



## 分组

分组的语法即 **()** ,分组的 子表达式 后面可以指定重复次数。

比如 ：**(\d{1,3}\.){3}\d{1,3}** 是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：**\d{1,3}**匹配1到3位的数字，**(\d{1,3}\.){3}**匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字**(\d{1,3})**。

不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)。

理解这个表达式的关键是理解2[0-4]\d|25[0-5]|[01]?\d\d?，这里我就不细说了，你自己应该能分析得出来它的意义。



## 反义



| 代码/语法 |                    说明                    |
| :-------: | :----------------------------------------: |
|    \W     | 匹配任意不是字母，数字，下划线，汉字的字符 |
|    \S     |          匹配任意不是空白符的字符          |
|    \D     |            匹配任意非数字的字符            |
|    \B     |        匹配不是单词开头或结束的位置        |
|   [^x]    |          匹配除了x以外的任意字符           |
| [^aeiou]  |   匹配除了aeiou这几个字母以外的任意字符    |



## 后向引用

后向引用基于分组。举个例子。

想匹配 Hello world Hello，这种 第一个 单词和 第三个 单词 一样的字符串。

怎么样才能 保证前后一致呢？这就需要用到 **后向引用**了。

**(H.{4}) world \1 **

这样就可以了，\1 代表第一个分组。



## 零宽断言

[这篇文章讲的海星](https://www.cnblogs.com/onepixel/articles/7717789.html)

#### 定义解释

用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。。最好还是拿例子来说明吧： 断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。

* 零宽正如它的名字一样，是一种零宽度的匹配，匹配到的内容不会保存到匹配结果里，最终匹配结果只是一个位置而已。

* **(?=exp)**也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。

  比如:**\b\w+(?=ing\b)**,匹配**I'm singing while you're dancing** ，就会匹配 **sing**,**danc**

* **(?<=exp)**也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。

  比如:**(?<=\bre)\w+\b**,匹配**reading a book**,就会匹配 **ading**



## 负向零宽断言

之前在**反义**里讲过怎么查找某个字符或不在某个字符里的字符方法。但我们如果只想确保某个字符不出现，但不想匹配的话该怎么办呢？比如我们想查找这样的单词—它里面出现了字母q，但是q后面不能是u。用反义的写法可以这样写。**\b\w*q\[^u]\w\*\b** ,但是这样写会有问题，因为 **\[^u]**这个=里会匹配一个字符，所以，如果q出现在单词的结尾的话，像**Iraq**,**Benq**，这个表达式就会出错。**Iraq fighting**这种带空格的也会使得**\[^u]**匹配，导致出错。

**负向零宽断言**就能解决这样的问题。因为它不会匹配字符，只是匹配位置(也就是**零宽**)。

即:**\b\w\*q(?!u)\w\*\b**

同理，我们可以用**(?<!exp)**,零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp。

比如：前面不是小写字母的7位数字

**(?<![a-z])\d{7}**



## 注释

小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。



## 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

有时，我们更需要懒惰匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。



| 代码/语法 |              说明               |
| :-------: | :-----------------------------: |
|    *?     |   重复任意次，但尽可能少重复    |
|    +?     | 重复1次或更多次，但尽可能少重复 |
|    ??     |  重复0次或1次，但尽可能少重复   |
|  {n,m}?   |   重复n到m次，但尽可能少重复    |
|   {n,}?   |   重复n次以上，但尽可能少重复   |





> 额，，，后面还有很多。。以后再码



[参考文章](http://deerchao.net/tutorials/regex/regex.htm)



## php里的正则表达式函数

* preg_match

  > ```php
  > int preg_match ( string $pattern , string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0 ]]] )
  > ```

  作用搜索subject与pattern的给定的正则表达式的一个匹配

* $pattern: 要搜索的模式，字符串形式。

* $subject: 输入字符串。

* $matches: 如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。

* $flags：flags 可以被设置为以下标记值：

  1. PREG_OFFSET_CAPTURE: 如果传递了这个标记，对于每一个出现的匹配返回时会附加字符串偏移量(相对于目标字符串的)。 注意：这会改变填充到matches参数的数组，使其每个元素成为一个由 第0个元素是匹配到的字符串，第1个元素是该匹配字符串 在目标字符串subject中的偏移量。

* offset: 通常，搜索从目标字符串的开始位置开始。可选参数 offset 用于 指定从目标字符串的某个未知开始搜索(单位是字节)。



## 练习题

1.请使用正则表达式，能够把以下符合美元价格格式的字符串匹配并可从一段字符串中提取出来："$200.49"、"$1,999.00"、"$99"、"50.00美元"。



2.不以th开头的单词匹配: \b(?!th)\w+\b

3.至少含有一个数字的4到8位密码： ^(?=.*\d).{4,8}

4.匹配一个中文字符：`/[\u4e00-\u9fa5]`

5.匹配ip地址：

> IP地址的规则：点号分开的四个字段，每个字段在0-255之间。

1. 第一步:第一个数如果是 1位或2位，肯定在255内。如果是3位，则0 1 开头也是合法的。

   即: **[01]?\d\d?**

2. 再看以2开头的3位数，十位数为0到4时 个位数 0到9都可以，为5时只能 0到5.

   即: **2\[0-4]\d|25[0-5]**



   3. 合起来就是 **[01]?\d\d?|2[0-4]\d|25]0-5]**

   4. 四个字段合起来就是

      /^(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.(?:[01]?\d\d?|2[0-4]\d|25[0-5])$/


6.匹配24小时制：

小时部分:[01]?[0-9]|2[0-3]

分钟部分: \[0-5][0-9]









